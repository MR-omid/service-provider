import hashlib
import hmac
import json
import urllib
import uuid
from urllib import parse
from components.Qhttp import Qhttp
from vendor.custom_exception import NetworkError, InternalModuleError, \
    LoginError, ResultNotFoundError, InstagramApiConstraint, InvalidInputError
from modules.instagram.v_1_0.parse_instagram import parse_profile, parse_follower_following, parse_search_contact, \
    parse_search_by_query


class Instagram:
    """
    :attribute loginUrl: login Url as a string
    :attribute mediaUrl: media Url as a string
    :attribute csrfUrl: csrftoken Url as a string
    :attribute commentURL: comment URL as a string
    :attribute media_likers_url: media likers URL as a string
    :attribute headers: headers as a dictionary
    :attribute ig_sig_key_version: ig_sig_key_version as a Int
    :attribute IG_SIG_KEY: IG_SIG_KEY as a dictionary
    """
    # urls:
    loginUrl = "https://i.instagram.com/api/v1/accounts/login/"
    mediaUrl = "https://i.instagram.com/api/v1/feed/user/{}/"
    csrfUrl = "https://i.instagram.com/api/v1/si/fetch_headers/?challenge_type=signup&guid={}"
    commentURL = "https://i.instagram.com/api/v1/media/{}/comments/"
    media_likers_url = "https://i.instagram.com/api/v1/media/{}/likers/"
    profile_url_user_id = 'https://i.instagram.com/api/v1/users/{}/info/'
    get_follower_url = 'https://i.instagram.com/api/v1/friendships/{}/followers/'
    get_following_url = 'https://i.instagram.com/api/v1/friendships/{}/following/'
    sync_address_book_url = 'https://i.instagram.com/api/v1/address_book/link/?include=extra_display_name,thumbnails'
    unlink_address_book_url = 'https://i.instagram.com/api/v1/address_book/unlink/'
    profile_url_username = 'https://i.instagram.com/api/v1/users/{}/usernameinfo/'
    search_by_query_url = 'https://i.instagram.com/api/v1/users/search/?query='
    ig_sig_key_version = '4'
    headers = {
        'User-Agent': 'Instagram 8.2.0 Android (18/4.3; 320dpi; 720x1280; Xiaomi; HM 1SW; armani; qcom; en_US)',
        'Connection': 'keep-Alive', 'Accept': '*/*', 'Accept-Language': 'en-US',
        'Content-type': 'application/x-www-form-urlencoded; charset=UTF-8'}
    IG_SIG_KEY = "55e91155636eaa89ba5ed619eb4645a4daf1103f2161dbfe6fd94d5ea7716095"

    def __init__(self, username, password, number, parent=None):
        """
        :attribute username: username as a string
        :attribute password: password as a string
        :attribute device_id: device ID generated by generateDeviceId method as a string
        :attribute isLoggedIn: it's True if user is login else Its False
        """
        self.username = username
        self.password = password
        self.request_number = number
        m = hashlib.md5()
        m.update(username.encode('utf-8') + password.encode('utf-8'))
        self.device_id = self.generate_device_id(m.hexdigest())
        self.session = Qhttp.session()
        self.isLoggedIn = False
        self.logged_in_user = ''
        self.token = ''
        self.username_id = ''
        self.rank_token = ''
        self.media_ids = ''
        self.parent = parent
        if self.parent:
            self.process_id = parent.task_model.process_id
        self.login_result = ''
        data = {'phone_id': self.generate_uuid(False),
                '_csrftoken': self.get_csrf_token(),
                'username': self.username,
                'password': self.password,
                'guid': self.generate_uuid(False),
                'device_id': self.device_id,
                'login_attempt_count': 0}
        self.data = json.dumps(data)

    def login(self):
        """
        this function login into Instagram account
        :return Returns boolean, If the user login correctly
        return True also it keeps logged user information
        """
        if not self.isLoggedIn:
            data = {'phone_id': self.generate_uuid(False),
                    '_csrftoken': self.get_csrf_token(),
                    'username': self.username,
                    'password': self.password,
                    'guid': self.generate_uuid(False),
                    'device_id': self.device_id,
                    'login_attempt_count': 0
                    }
            json_data = json.dumps(data)
            try:
                r = self.session.post(url=Instagram.loginUrl, data=self.generate_signature(json_data),
                                      headers=self.headers)
            except Exception as e:
                raise NetworkError(e)
            result = r.json()
            self.login_result = result
            if r.status_code == 200:
                if 'status' in r.text:
                    if result['status'] == 'ok':
                        self.isLoggedIn = True
                        self.logged_in_user = result["logged_in_user"]
                        self.token = r.cookies['csrftoken']
                        self.username_id = result["logged_in_user"]["pk"]  # pk
                        self.rank_token = "{}_{}".format(self.username_id, self.generate_uuid(False))
                        return True
                    else:
                        if 'message' in result:
                            raise LoginError(result['message'])
                        else:
                            raise LoginError('can not login')
                else:
                    if 'message' in result:
                        raise LoginError(result['message'])
                    else:
                        raise LoginError('can not login')
            else:
                if 'error_type' in result:
                    if result['error_type'] == 'rate_limit_error':
                        raise InstagramApiConstraint('rate limit error, Please wait a few minutes before you try again')
                if 'message' in result:

                    raise LoginError(result['message'])
                else:
                    raise LoginError('can not login')
        else:
            return True

    def update_progressbar(self, message, percent):
        """
        :param message: message of new state
        :param percent: total percent
        update progressbar value of request
        """
        if self.parent:
            self.parent.progress = {'state': message, 'percent': percent}

    def profile(self, user_id):
        """
        this function show the user's post
        :param user_id: user_id or username as string, set for profile request
        :return Returns a json of user's account info
        """
        if not self.isLoggedIn:
            self.login()
        self.update_progressbar('request submitted: check profile', 10)
        if user_id.isdigit():  # create url base on username or pk received
            url = Instagram.profile_url_user_id.format(user_id)
        else:
            url = Instagram.profile_url_username.format(user_id)
        self.update_progressbar('set request to instagram api', 20)
        try:  # set request to insta
            r = self.session.get(url=url, data=Instagram.generate_signature(self, data=self.data), headers=self.headers)
        except Exception:
            raise NetworkError(' can not access api')
        if r.status_code == 200:
            result = r.json()
            if self.parent:
                self.parent.check_point()
            self.update_progressbar('parse_result', 80)
            result = parse_profile(result, user_id, self.process_id)
            return result
        else:
            if r.status_code == 404:
                raise ResultNotFoundError('not found profile')
            else:
                raise NetworkError(r.status_code)

    def get_follower_following(self, user_id, request_type):
        """
        this function show the user's follower/following list
        :param user_id: user_id or username as string
        :param request_type: follower/ following
        :return Returns a json of user's account info
        """
        if not self.isLoggedIn:
            self.login()
        base_url = ''
        user = []
        self.update_progressbar('request submitted: get follower', 10)
        # preparing urls:
        if request_type == 'follower':
            if user_id.isdigit():  # create url base on username or pk received
                base_url = Instagram.get_follower_url.format(user_id)
            else:
                pk = self.profile(user_id)[1]['pk']
                base_url = Instagram.get_follower_url.format(pk)

        elif request_type == 'following':
            if user_id.isdigit():  # create url base on username or pk received
                base_url = Instagram.get_following_url.format(user_id)
            else:

                pk = self.profile(user_id)[1]['pk']
                base_url = Instagram.get_following_url.format(pk)
        self.update_progressbar('set request to Instagram api', 20)

        if self.parent:
            self.parent.check_point()
        try:  # set request to insta
            r = self.session.get(url=base_url, data=Instagram.generate_signature(self, data=self.data),
                                 headers=self.headers)
        except Exception as e:
            raise NetworkError(' can not access api' + e.__str__())
        if r.status_code == 200:
            result = r.json()
            if self.parent:
                self.parent.check_point()
            user.extend(result['users'])
        else:
            if r.status_code == 404:
                raise ResultNotFoundError('not found profile')
            else:
                raise NetworkError(r.status_code, r.text)
        while True:  # continue to extract person til reach request number or follower/following list finish
            if self.parent:
                self.parent.check_point()
            if len(user) <= self.request_number:
                if 'next_max_id' in result.keys():
                    max_id = result['next_max_id']  # extract person from continues list
                    try:  # set request to insta
                        url = base_url + '?max_id=' + max_id
                        r = self.session.get(url=url, data=Instagram.generate_signature(self, data=self.data),
                                             headers=self.headers)
                    except Exception:
                        break  # in case of that s.t happening and can not extract more person
                    try:
                        if r.status_code == 200:
                            result = r.json()
                            if self.parent:
                                self.parent.check_point()
                            # parsing results
                            user.extend(result['users']) # adding profiles tp result till reach max_result number
                        else:
                            break  # in case of that s.t happening and can not extract more person
                    except Exception:
                        break  # in case of that s.t happening and can not extract more person
                else:
                    break  # in case of reaching end of follower/following list
            else:
                break  # in case of reaching request number
        # parsing result from extract info
        if self.parent:
            self.parent.check_point()
        self.update_progressbar('parse_result', 80)
        result = parse_follower_following(user, user_id, self.process_id, self.request_number)
        return result

    def search_by_query(self, query):
        """
        this function search thought instagram by query
        :param query: query string
        :return Returns a json of results
        """
        if not self.isLoggedIn:
            self.login()
        return_result = {}
        r = self.session.post(url=Instagram.search_by_query_url + query,
                              data=Instagram.generate_signature(self, data=self.data), headers=self.headers)
        if r.status_code == 200:
            lastJson = json.loads(r.text)
            result = lastJson
            if result["status"] != "ok":
                raise ResultNotFoundError(' result is not ok')
            if result['users']:
                try:
                    return_result = parse_search_by_query(result['users'], self.process_id)
                except Exception as e:
                    raise InternalModuleError(e.__str__())
            if return_result:
                return return_result
            else:
                raise ResultNotFoundError('can not find any result')
        else:
            raise ResultNotFoundError(r.status_code)

    def search_number(self, number):
        if not self.isLoggedIn:
            self.login()
        contacts = []
        return_result = ''
        contact = dict()
        if not str(int(number)).isdigit():
            raise InvalidInputError('invalid phone number format')
        contact["phone_numbers"] = [number]
        contact["first_name"] = number
        contact["email_addresses"] = []
        contacts.append(contact)

        r = self.session.post(
            url= Instagram.sync_address_book_url,
            data="contacts=" + json.dumps(contacts),
            headers=self.headers)

        if r.status_code == 200:
            lastJson = json.loads(r.text)
            result = lastJson
            if result["status"] != "ok":
                raise ResultNotFoundError(' result is not ok')
            for item in result["items"]:
                try:
                    return_result = parse_search_contact(item['user'], self.process_id)

                except Exception:
                    continue
            a = self.session.post(
                url=Instagram.unlink_address_book_url,
                headers=self.headers)
            if return_result:
                return return_result
            else:
                a = self.session.post(
                    url=Instagram.unlink_address_book_url,
                    headers=self.headers)
                raise ResultNotFoundError('user that belong to this phone number not found')
        else:
            a = self.session.post(
                url=Instagram.unlink_address_book_url,
                headers=self.headers)
            raise ResultNotFoundError(r.text)

    @staticmethod
    def generate_uuid(edit):
        """
        this function generate for specific user
        :param edit: boolean value, if True '-' replace by ''
        :return Returns uuid as string
        """
        generated_uuid = str(uuid.uuid4())
        if edit:
            return generated_uuid.replace('-', '')
        else:
            return generated_uuid

    def get_csrf_token(self):
        """
        this function generate csrf_token
        :return Returns csrf_token as string

        """
        try:
            url = self.csrfUrl.format(self.generate_uuid(True))
            r = Qhttp.get(url, headers=self.headers)
            if json.loads(r.text)['status'] == 'ok':
                csrf_token = r.cookies['csrftoken']
                return csrf_token
            else:
                raise NetworkError(r.text)
        except Exception as e:
            raise NetworkError(e.__str__())

    @staticmethod
    def generate_device_id(seed):
        """
        this function generate DeviceId
        :return Returns DeviceId as string
        """
        try:
            volatile_seed = "12345"
            m = hashlib.md5()
            m.update(seed.encode('utf-8') + volatile_seed.encode('utf-8'))
            return 'android-' + m.hexdigest()[:16]
        except Exception:
            raise Exception

    def generate_signature(self, data, skip_quote=False):
        """
        this function convert data to encrypted data
        :return Returns encrypted data as string
        """

        if not skip_quote:
            try:
                parsed_data = urllib.parse.quote(data)
            except AttributeError:
                parsed_data = urllib.quote(data)
        else:
            parsed_data = data
        return 'ig_sig_key_version=4&signed_body=' + hmac.new(self.IG_SIG_KEY.encode('utf-8'),
                                                              data.encode('utf-8'), hashlib.sha256).hexdigest() + \
               '.' + parsed_data + '&ig_sig_key_version={}'.format(self.ig_sig_key_version)

    def generate_rank_token(self):
        """
        this function generate rank token
        :return Returns rank token as string
        """
        try:
            account_id = self.login_result["logged_in_user"]["pk"]
            account_uuid = self.generate_uuid(True)
            return str(account_id) + '_' + str(account_uuid)
        except Exception as e:
            raise NetworkError(e.__str__())
